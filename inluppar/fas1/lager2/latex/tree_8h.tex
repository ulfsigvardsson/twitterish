\hypertarget{tree_8h}{}\section{tree.\+h filreferens}
\label{tree_8h}\index{tree.\+h@{tree.\+h}}
{\ttfamily \#include $<$stdbool.\+h$>$}\\*
{\ttfamily \#include \char`\"{}common.\+h\char`\"{}}\\*
Include-\/beroendediagram för tree.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{tree_8h__incl}
\end{center}
\end{figure}
Den här grafen visar vilka filer som direkt eller indirekt inkluderar denna filen.\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=245pt]{tree_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Definitioner}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{tree_8h_ac1737de07bd116e8c179726df0a30780}{tree\+\_\+update}(t,  k,  e,  tmp)~(\hyperlink{tree_8h_a509c042f786ab4f4c3991947d7f98a8a}{tree\+\_\+remove}(t, k, \&tmp) ? \hyperlink{tree_8h_ab7d2e892ded2ae3fca90b1f7fbcd0f07}{tree\+\_\+insert}(t, k, e) \+: false)
\end{DoxyCompactItemize}
\subsection*{Typdefinitioner}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{common_8h_a7fdd31df4fac71b8c34af47c7d45226a}{elem\+\_\+t} \hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t}
\item 
typedef \hyperlink{common_8h_a66551bc5a869ff55fd6e97cdf83f9e27}{element\+\_\+free\+\_\+fun} \hyperlink{tree_8h_aa6e72bc7040d433d1054d4f89e0b3493}{key\+\_\+free\+\_\+fun}
\item 
typedef struct \hyperlink{structtree}{tree} \hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t}
\item 
typedef struct \hyperlink{structnode}{node} \hyperlink{tree_8h_a7c02633e18d6aa5f58539b75f08753d9}{node\+\_\+t}
\item 
typedef bool($\ast$ \hyperlink{tree_8h_a7da81ed45282293e2728c4e80c10e634}{key\+\_\+elem\+\_\+apply\+\_\+fun}) (\hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t} key, \hyperlink{common_8h_a7fdd31df4fac71b8c34af47c7d45226a}{elem\+\_\+t} elem, void $\ast$data)
\end{DoxyCompactItemize}
\subsection*{Egenuppräknande typer}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{tree_8h_abe996c0b99220479aa7355185109749f}{tree\+\_\+order} \{ \hyperlink{tree_8h_abe996c0b99220479aa7355185109749faa002ebdf4489d42997eeeb3f424381c8}{inorder} = 0, 
\hyperlink{tree_8h_abe996c0b99220479aa7355185109749fadefb5d09673c144dc5b4dc177e278696}{preorder} = -\/1, 
\hyperlink{tree_8h_abe996c0b99220479aa7355185109749fa2b26810565bd469bf0fcda626669d3dc}{postorder} = 1
 \}
\end{DoxyCompactItemize}
\subsection*{Funktioner}
\begin{DoxyCompactItemize}
\item 
\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$ \hyperlink{tree_8h_a6a795c729d8a09e5877f7f1ddfb7c91c}{tree\+\_\+new} (\hyperlink{common_8h_a0ca91ee5ad428d2cb3161e07618bd21c}{element\+\_\+copy\+\_\+fun} element\+\_\+copy, \hyperlink{tree_8h_aa6e72bc7040d433d1054d4f89e0b3493}{key\+\_\+free\+\_\+fun} key\+\_\+free, \hyperlink{common_8h_a66551bc5a869ff55fd6e97cdf83f9e27}{element\+\_\+free\+\_\+fun} \hyperlink{test_8c_a06928f6db1213c0a2e410fd6693383d4}{elem\+\_\+free}, \hyperlink{common_8h_a1ae319bacbeb687146c87de665a96b35}{element\+\_\+comp\+\_\+fun} compare)
\item 
void \hyperlink{tree_8h_afc9838326212e7731f31dcf237e7b76d}{tree\+\_\+delete} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree}, bool delete\+\_\+keys, bool delete\+\_\+elements)
\item 
int \hyperlink{tree_8h_a13827cc121c0826bccee80991ac7dd04}{tree\+\_\+size} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree})
\item 
int \hyperlink{tree_8h_ac892293edb990109e99f00807f1a9fcd}{tree\+\_\+depth} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree})
\item 
bool \hyperlink{tree_8h_ab7d2e892ded2ae3fca90b1f7fbcd0f07}{tree\+\_\+insert} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree}, \hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t} key, \hyperlink{common_8h_a7fdd31df4fac71b8c34af47c7d45226a}{elem\+\_\+t} elem)
\item 
bool \hyperlink{tree_8h_a102b066d4b37f6d31765118d39e39202}{tree\+\_\+has\+\_\+key} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree}, \hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t} key)
\item 
bool \hyperlink{tree_8h_a678b7a8152b3ec50963dd2529950a016}{tree\+\_\+get} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree}, \hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t} key, \hyperlink{common_8h_a7fdd31df4fac71b8c34af47c7d45226a}{elem\+\_\+t} $\ast$result)
\item 
bool \hyperlink{tree_8h_a509c042f786ab4f4c3991947d7f98a8a}{tree\+\_\+remove} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree}, \hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t} key, \hyperlink{common_8h_a7fdd31df4fac71b8c34af47c7d45226a}{elem\+\_\+t} $\ast$result)
\item 
\hyperlink{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{tree\+\_\+key\+\_\+t} $\ast$ \hyperlink{tree_8h_a2e86ac9f939bfc474c8026be870adadb}{tree\+\_\+keys} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree})
\item 
\hyperlink{common_8h_a7fdd31df4fac71b8c34af47c7d45226a}{elem\+\_\+t} $\ast$ \hyperlink{tree_8h_a1428bfa67d419b8bf13824adfc3458f8}{tree\+\_\+elements} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree})
\item 
bool \hyperlink{tree_8h_a78a81f99c6b5a1014726bd91d0fda32e}{tree\+\_\+apply} (\hyperlink{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{tree\+\_\+t} $\ast$\hyperlink{structtree}{tree}, enum \hyperlink{tree_8h_abe996c0b99220479aa7355185109749f}{tree\+\_\+order} order, \hyperlink{tree_8h_a7da81ed45282293e2728c4e80c10e634}{key\+\_\+elem\+\_\+apply\+\_\+fun} fun, void $\ast$data)
\end{DoxyCompactItemize}


\subsection{Dokumentation över definitioner}
\index{tree.\+h@{tree.\+h}!tree\+\_\+update@{tree\+\_\+update}}
\index{tree\+\_\+update@{tree\+\_\+update}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+update}{tree_update}}]{\setlength{\rightskip}{0pt plus 5cm}\#define tree\+\_\+update(
\begin{DoxyParamCaption}
\item[{}]{t, }
\item[{}]{k, }
\item[{}]{e, }
\item[{}]{tmp}
\end{DoxyParamCaption}
)~({\bf tree\+\_\+remove}(t, k, \&tmp) ? {\bf tree\+\_\+insert}(t, k, e) \+: false)}\hypertarget{tree_8h_ac1737de07bd116e8c179726df0a30780}{}\label{tree_8h_ac1737de07bd116e8c179726df0a30780}
Swap the element for a given key for another.


\begin{DoxyParams}{Parametrar}
{\em t} & pointer to the tree \\
\hline
{\em k} & the key of elem to be changed \\
\hline
{\em e} & the updated element \\
\hline
{\em result} & a elem\+\_\+t where result will be stored (only defined when result is true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
true if both operations succeeded 
\end{DoxyReturn}


\subsection{Dokumentation över typdefinitioner}
\index{tree.\+h@{tree.\+h}!key\+\_\+elem\+\_\+apply\+\_\+fun@{key\+\_\+elem\+\_\+apply\+\_\+fun}}
\index{key\+\_\+elem\+\_\+apply\+\_\+fun@{key\+\_\+elem\+\_\+apply\+\_\+fun}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{key\+\_\+elem\+\_\+apply\+\_\+fun}{key_elem_apply_fun}}]{\setlength{\rightskip}{0pt plus 5cm}typedef bool($\ast$ key\+\_\+elem\+\_\+apply\+\_\+fun) ({\bf tree\+\_\+key\+\_\+t} key, {\bf elem\+\_\+t} elem, void $\ast$data)}\hypertarget{tree_8h_a7da81ed45282293e2728c4e80c10e634}{}\label{tree_8h_a7da81ed45282293e2728c4e80c10e634}
This function is used in \hyperlink{tree_8h_a78a81f99c6b5a1014726bd91d0fda32e}{tree\+\_\+apply()} to allow applying a function to all elements in a tree. \index{tree.\+h@{tree.\+h}!key\+\_\+free\+\_\+fun@{key\+\_\+free\+\_\+fun}}
\index{key\+\_\+free\+\_\+fun@{key\+\_\+free\+\_\+fun}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{key\+\_\+free\+\_\+fun}{key_free_fun}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf element\+\_\+free\+\_\+fun} {\bf key\+\_\+free\+\_\+fun}}\hypertarget{tree_8h_aa6e72bc7040d433d1054d4f89e0b3493}{}\label{tree_8h_aa6e72bc7040d433d1054d4f89e0b3493}
\index{tree.\+h@{tree.\+h}!node\+\_\+t@{node\+\_\+t}}
\index{node\+\_\+t@{node\+\_\+t}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{node\+\_\+t}{node_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf node} {\bf node\+\_\+t}}\hypertarget{tree_8h_a7c02633e18d6aa5f58539b75f08753d9}{}\label{tree_8h_a7c02633e18d6aa5f58539b75f08753d9}
\index{tree.\+h@{tree.\+h}!tree\+\_\+key\+\_\+t@{tree\+\_\+key\+\_\+t}}
\index{tree\+\_\+key\+\_\+t@{tree\+\_\+key\+\_\+t}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+key\+\_\+t}{tree_key_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf elem\+\_\+t} {\bf tree\+\_\+key\+\_\+t}}\hypertarget{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}{}\label{tree_8h_af42dd67b55ffc67649d20c46e9cbf84f}
\index{tree.\+h@{tree.\+h}!tree\+\_\+t@{tree\+\_\+t}}
\index{tree\+\_\+t@{tree\+\_\+t}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+t}{tree_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf tree} {\bf tree\+\_\+t}}\hypertarget{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}{}\label{tree_8h_aabd08cfd7893b1b0d401ce689de8c1b7}


\subsection{Dokumentation över egenuppräknande typer}
\index{tree.\+h@{tree.\+h}!tree\+\_\+order@{tree\+\_\+order}}
\index{tree\+\_\+order@{tree\+\_\+order}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+order}{tree_order}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tree\+\_\+order}}\hypertarget{tree_8h_abe996c0b99220479aa7355185109749f}{}\label{tree_8h_abe996c0b99220479aa7355185109749f}
\begin{Desc}
\item[Egenuppräknade typers värden]\par
\begin{description}
\index{inorder@{inorder}!tree.\+h@{tree.\+h}}\index{tree.\+h@{tree.\+h}!inorder@{inorder}}\item[{\em 
inorder\hypertarget{tree_8h_abe996c0b99220479aa7355185109749faa002ebdf4489d42997eeeb3f424381c8}{}\label{tree_8h_abe996c0b99220479aa7355185109749faa002ebdf4489d42997eeeb3f424381c8}
}]\index{preorder@{preorder}!tree.\+h@{tree.\+h}}\index{tree.\+h@{tree.\+h}!preorder@{preorder}}\item[{\em 
preorder\hypertarget{tree_8h_abe996c0b99220479aa7355185109749fadefb5d09673c144dc5b4dc177e278696}{}\label{tree_8h_abe996c0b99220479aa7355185109749fadefb5d09673c144dc5b4dc177e278696}
}]\index{postorder@{postorder}!tree.\+h@{tree.\+h}}\index{tree.\+h@{tree.\+h}!postorder@{postorder}}\item[{\em 
postorder\hypertarget{tree_8h_abe996c0b99220479aa7355185109749fa2b26810565bd469bf0fcda626669d3dc}{}\label{tree_8h_abe996c0b99220479aa7355185109749fa2b26810565bd469bf0fcda626669d3dc}
}]\end{description}
\end{Desc}


\subsection{Dokumentation över funktioner}
\index{tree.\+h@{tree.\+h}!tree\+\_\+apply@{tree\+\_\+apply}}
\index{tree\+\_\+apply@{tree\+\_\+apply}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+apply(tree\+\_\+t $\ast$tree, enum tree\+\_\+order order, key\+\_\+elem\+\_\+apply\+\_\+fun fun, void $\ast$data)}{tree_apply(tree_t *tree, enum tree_order order, key_elem_apply_fun fun, void *data)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tree\+\_\+apply (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree, }
\item[{enum {\bf tree\+\_\+order}}]{order, }
\item[{{\bf key\+\_\+elem\+\_\+apply\+\_\+fun}}]{fun, }
\item[{void $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a78a81f99c6b5a1014726bd91d0fda32e}{}\label{tree_8h_a78a81f99c6b5a1014726bd91d0fda32e}
Applies a function to all elements in the tree in a specified order. Example (using shelf as key)\+: \begin{DoxyVerb}tree_t *t = tree_new();
tree_insert(t, "A25", some_item);
int number = 0;
tree_apply(t, inorder, print_item, &number);
\end{DoxyVerb}


where print\+\_\+item is a function that prints the number and increments it, and prints the item passed to it.


\begin{DoxyParams}{Parametrar}
{\em tree} & the tree \\
\hline
{\em order} & the order in which the elements will be visited \\
\hline
{\em fun} & the function to apply to all elements \\
\hline
{\em data} & an extra argument passed to each call to fun (may be N\+U\+LL) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
the result of all fun calls, combined with OR ($\vert$$\vert$) 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+delete@{tree\+\_\+delete}}
\index{tree\+\_\+delete@{tree\+\_\+delete}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+delete(tree\+\_\+t $\ast$tree, bool delete\+\_\+keys, bool delete\+\_\+elements)}{tree_delete(tree_t *tree, bool delete_keys, bool delete_elements)}}]{\setlength{\rightskip}{0pt plus 5cm}void tree\+\_\+delete (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree, }
\item[{bool}]{delete\+\_\+keys, }
\item[{bool}]{delete\+\_\+elements}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_afc9838326212e7731f31dcf237e7b76d}{}\label{tree_8h_afc9838326212e7731f31dcf237e7b76d}
Remove a tree along with all elem\+\_\+t elements.


\begin{DoxyParams}{Parametrar}
{\em tree} & the tree \\
\hline
{\em delete\+\_\+keys} & if true, run tree\textquotesingle{}s key\+\_\+free function on all keys \\
\hline
{\em delete\+\_\+elements} & if true, run tree\textquotesingle{}s elem\+\_\+free function on all elements \\
\hline
\end{DoxyParams}
\index{tree.\+h@{tree.\+h}!tree\+\_\+depth@{tree\+\_\+depth}}
\index{tree\+\_\+depth@{tree\+\_\+depth}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+depth(tree\+\_\+t $\ast$tree)}{tree_depth(tree_t *tree)}}]{\setlength{\rightskip}{0pt plus 5cm}int tree\+\_\+depth (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_ac892293edb990109e99f00807f1a9fcd}{}\label{tree_8h_ac892293edb990109e99f00807f1a9fcd}
Get the depth of the tree

\begin{DoxyReturn}{Returnerar}
\+: the depth of the deepest subtree 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+elements@{tree\+\_\+elements}}
\index{tree\+\_\+elements@{tree\+\_\+elements}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+elements(tree\+\_\+t $\ast$tree)}{tree_elements(tree_t *tree)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf elem\+\_\+t}$\ast$ tree\+\_\+elements (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a1428bfa67d419b8bf13824adfc3458f8}{}\label{tree_8h_a1428bfa67d419b8bf13824adfc3458f8}
Returns an array holding all the elements in the tree in ascending order of their keys (which are not part of the value).


\begin{DoxyParams}{Parametrar}
{\em tree} & pointer to the tree \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: array of \hyperlink{tree_8h_a13827cc121c0826bccee80991ac7dd04}{tree\+\_\+size()} elements 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+get@{tree\+\_\+get}}
\index{tree\+\_\+get@{tree\+\_\+get}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+get(tree\+\_\+t $\ast$tree, tree\+\_\+key\+\_\+t key, elem\+\_\+t $\ast$result)}{tree_get(tree_t *tree, tree_key_t key, elem_t *result)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tree\+\_\+get (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree, }
\item[{{\bf tree\+\_\+key\+\_\+t}}]{key, }
\item[{{\bf elem\+\_\+t} $\ast$}]{result}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a678b7a8152b3ec50963dd2529950a016}{}\label{tree_8h_a678b7a8152b3ec50963dd2529950a016}
Finds the element for a given key in tree.


\begin{DoxyParams}{Parametrar}
{\em tree} & pointer to the tree \\
\hline
{\em key} & the key of elem to be removed \\
\hline
{\em result} & a pointer to where result can be stored (only defined when result is true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: true if key is a key in the tree 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+has\+\_\+key@{tree\+\_\+has\+\_\+key}}
\index{tree\+\_\+has\+\_\+key@{tree\+\_\+has\+\_\+key}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+has\+\_\+key(tree\+\_\+t $\ast$tree, tree\+\_\+key\+\_\+t key)}{tree_has_key(tree_t *tree, tree_key_t key)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tree\+\_\+has\+\_\+key (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree, }
\item[{{\bf tree\+\_\+key\+\_\+t}}]{key}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a102b066d4b37f6d31765118d39e39202}{}\label{tree_8h_a102b066d4b37f6d31765118d39e39202}
Checks whether a key is used in a tree

Uses the tree\textquotesingle{}s compare function to compare keys.


\begin{DoxyParams}{Parametrar}
{\em tree} & pointer to the tree \\
\hline
{\em key} & the key to check for inclusion in the tree \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: true if key is a key in the tree 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+insert@{tree\+\_\+insert}}
\index{tree\+\_\+insert@{tree\+\_\+insert}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+insert(tree\+\_\+t $\ast$tree, tree\+\_\+key\+\_\+t key, elem\+\_\+t elem)}{tree_insert(tree_t *tree, tree_key_t key, elem_t elem)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tree\+\_\+insert (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree, }
\item[{{\bf tree\+\_\+key\+\_\+t}}]{key, }
\item[{{\bf elem\+\_\+t}}]{elem}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_ab7d2e892ded2ae3fca90b1f7fbcd0f07}{}\label{tree_8h_ab7d2e892ded2ae3fca90b1f7fbcd0f07}
Insert element into the tree. Returns false if the key is already used.

Uses the tree\textquotesingle{}s compare function to compare keys.

If tree\textquotesingle{}s copy function is non-\/\+N\+U\+LL, it will be applied to elem and its result stored in the tree. Otherwise, elem will be stored in the tree. Note that keys are never copied and are assumed to be immutable. (They may however be freed by the tree.)


\begin{DoxyParams}{Parametrar}
{\em tree} & pointer to the tree \\
\hline
{\em key} & the key of element to be appended -- this is assumed to be an immutable value \\
\hline
{\em elem} & the element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: true if successful, else false 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+keys@{tree\+\_\+keys}}
\index{tree\+\_\+keys@{tree\+\_\+keys}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+keys(tree\+\_\+t $\ast$tree)}{tree_keys(tree_t *tree)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf tree\+\_\+key\+\_\+t}$\ast$ tree\+\_\+keys (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a2e86ac9f939bfc474c8026be870adadb}{}\label{tree_8h_a2e86ac9f939bfc474c8026be870adadb}
Returns an array holding all the keys in the tree in ascending order.


\begin{DoxyParams}{Parametrar}
{\em tree} & pointer to the tree \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: array of \hyperlink{tree_8h_a13827cc121c0826bccee80991ac7dd04}{tree\+\_\+size()} keys 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+new@{tree\+\_\+new}}
\index{tree\+\_\+new@{tree\+\_\+new}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+new(element\+\_\+copy\+\_\+fun element\+\_\+copy, key\+\_\+free\+\_\+fun key\+\_\+free, element\+\_\+free\+\_\+fun elem\+\_\+free, element\+\_\+comp\+\_\+fun compare)}{tree_new(element_copy_fun element_copy, key_free_fun key_free, element_free_fun elem_free, element_comp_fun compare)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf tree\+\_\+t}$\ast$ tree\+\_\+new (
\begin{DoxyParamCaption}
\item[{{\bf element\+\_\+copy\+\_\+fun}}]{element\+\_\+copy, }
\item[{{\bf key\+\_\+free\+\_\+fun}}]{key\+\_\+free, }
\item[{{\bf element\+\_\+free\+\_\+fun}}]{elem\+\_\+free, }
\item[{{\bf element\+\_\+comp\+\_\+fun}}]{compare}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a6a795c729d8a09e5877f7f1ddfb7c91c}{}\label{tree_8h_a6a795c729d8a09e5877f7f1ddfb7c91c}
Creates a new tree


\begin{DoxyParams}[1]{Parametrar}
\mbox{\tt in}  & {\em copy} & (may be N\+U\+LL) a function applied to all elements when stored in the tree \\
\hline
 & {\em key\+\_\+free} & (may be N\+U\+LL) used to free keys in tree\+\_\+delete \\
\hline
 & {\em elem\+\_\+free} & (may be N\+U\+LL) used to free elements in tree\+\_\+delete \\
\hline
 & {\em compare} & (may be N\+U\+LL) used to compare keys \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: empty tree
\end{DoxyReturn}
Creates a new tree


\begin{DoxyParams}{Parametrar}
{\em copy} & (may be N\+U\+LL) a function applied to all elements when stored in the tree \\
\hline
{\em key\+\_\+free} & (may be N\+U\+LL) used to free keys in tree\+\_\+delete \\
\hline
{\em elem\+\_\+free} & (may be N\+U\+LL) used to free elements in tree\+\_\+delete \\
\hline
{\em compare} & (may be N\+U\+LL) used to compare keys \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: empty tree 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+remove@{tree\+\_\+remove}}
\index{tree\+\_\+remove@{tree\+\_\+remove}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+remove(tree\+\_\+t $\ast$tree, tree\+\_\+key\+\_\+t key, elem\+\_\+t $\ast$result)}{tree_remove(tree_t *tree, tree_key_t key, elem_t *result)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tree\+\_\+remove (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree, }
\item[{{\bf tree\+\_\+key\+\_\+t}}]{key, }
\item[{{\bf elem\+\_\+t} $\ast$}]{result}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a509c042f786ab4f4c3991947d7f98a8a}{}\label{tree_8h_a509c042f786ab4f4c3991947d7f98a8a}
Removes the element for a given key in tree.


\begin{DoxyParams}{Parametrar}
{\em tree} & pointer to the tree \\
\hline
{\em key} & the key of elem to be removed \\
\hline
{\em result} & a pointer to where result can be stored (only defined when result is true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returnerar}
\+: true if key is a key in the tree 
\end{DoxyReturn}
\index{tree.\+h@{tree.\+h}!tree\+\_\+size@{tree\+\_\+size}}
\index{tree\+\_\+size@{tree\+\_\+size}!tree.\+h@{tree.\+h}}
\subsubsection[{\texorpdfstring{tree\+\_\+size(tree\+\_\+t $\ast$tree)}{tree_size(tree_t *tree)}}]{\setlength{\rightskip}{0pt plus 5cm}int tree\+\_\+size (
\begin{DoxyParamCaption}
\item[{{\bf tree\+\_\+t} $\ast$}]{tree}
\end{DoxyParamCaption}
)}\hypertarget{tree_8h_a13827cc121c0826bccee80991ac7dd04}{}\label{tree_8h_a13827cc121c0826bccee80991ac7dd04}
Get the size of the tree

\begin{DoxyReturn}{Returnerar}
\+: the number of nodes in the tree 
\end{DoxyReturn}
